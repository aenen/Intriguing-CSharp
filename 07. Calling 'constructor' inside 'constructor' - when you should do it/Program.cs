using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// "07. Виклик 'конструктора' всередині 'конструктора' - коли варто це робити"
namespace _07
{

    /* C# пропонує простий синтаксис, який дозволяє ініціалізувати поля під час створення об'єку посильного типу:       
       internal sealed class SomeType {
           private Int32 m_x = 5;
       }
       
       Під час створення об'єкту SomeType поле m_x ініціалізується значенням 5. Ви можете спитити:
       як це відбувається? Подивившись IL-код методу-конструктору цього об'єкту можна побачити наступний код:
       internal sealed class SomeType {
           private Int32 m_x;

           public SomeType() : base()
           {
               mx = 5;
           }
       } */



    /* Подивіться, наскільки може розростись IL-код, якщо використовувати явну ініціалізацію полей
       та мати кілька конструкторів. Закоментований код ініціалізації полей в конструкторах - це те,
       що буде знаходитись в IL-коді після компіляції. */
    internal sealed class SomeTypeOne
    {
        private Int32 m_x = 5;
        private String m_s = "Hi there";
        private Double m_d = 3.14159;
        private Byte m_b;

        // Це конструктори
        public SomeTypeOne() //: base()
        {
            // m_x = 5;
            // m_s = "Hi there";
            // m_d = 3.14159;
        }
        public SomeTypeOne(Int32 x) //: base()
        {
            // m_x = 5;
            // m_s = "Hi there";
            // m_d = 3.14159;
        }
        public SomeTypeOne(String s) //: base()
        {
            // m_x = 5;
            // m_s = "Hi there";
            // m_d = 3.14159;
            m_d = 10;
        }
    }



    /* Якщо є кілька ініціалізуємих екземплярних полей і багато перевантажених
       методів-конструкторів, варто подумати про те, щоб визначити поля без ініціалізації.
       Створити єдиний конструктор, який виконує загальну ініціалізацію і змусити кожен
       метод-конструктор явно викликати конструктор, який виконує загальну ініціалізацію. 
       Цей підхід дозволить зменшити розмір генерованого коду. */
    internal sealed class SomeTypeTwo
    {
        // Тут немає коду, який явно ініціалізує поля:
        private Int32 m_x;
        private String m_s;
        private Double m_d;
        private Byte m_b;

        // Код цього конструктору ініціалізує поля значеннями за замовчуванням
        // Цей конструктор повинен викликатись всіма іншими конструкторами
        public SomeTypeTwo()
        {
            m_x = 5;
            m_s = "Hi there";
            m_d = 3.14159;
            m_b = 0xff;
        }

        // Цей конструктор ініціалізує поля значеннями за замовчуванням,
        // а потім змінює значення m_x
        public SomeTypeTwo(Int32 x) : this() // Зверніть увагу на виклик конструктора без параметрів цього типу: this()
        {
            m_x = x;
        }

        // Цей конструктор ініціалізує поля значеннями за замовчуванням,
        // а потім змінює значення m_s
        public SomeTypeTwo(String s) : this()
        {
            m_s = s;
        }

        // Цей конструктор ініціалізує поля значеннями за замовчуванням,
        // а потім змінює значення m_x і m_s
        public SomeTypeTwo(Int32 x, String s) : this()
        {
            m_x = x;
            m_s = s;
        }
    }
}
